{"version":3,"sources":["../../src/lib/common/get-node-key.ts","../../src/lib/common/tokens.ts","../../node_modules/tslib/tslib.es6.js","../../src/lib/api/event.replayer.ts","../../src/lib/api/event.recorder.ts","../../src/lib/api/inline.preboot.code.ts","../../src/lib/provider.ts","../../src/lib/module.ts"],"names":["getNodeKeyForPreboot","nodeContext","ancestors","root","node","temp","serverNode","clientNode","push","parentNode","key","nodeName","i","length","childNodes","j","n","nodeType","PREBOOT_NONCE","InjectionToken","Object","create","__values","o","s","Symbol","iterator","m","call","next","value","done","TypeError","_window","prebootData","window","getComputedStyle","document","EventReplayer","this","clientNodeCache","replayStarted","prototype","setWindow","win","getWindow","replayAll","_this","apps","forEach","appData","replayForApp","cleanup","events","event","replayEvent","ex","console","error","switchBuffer","prebootEvent","nodeKey","findClientNode","checked","selected","dispatchEvent","warn","type","serverView","clientView","display","gcs","getPropertyValue","remove","style","listeners","activeNode","setTimeout","setFocus","listeners_1","listeners_1_1","listener","removeEventListener","eventName","handler","doc","prebootOverlay","getElementById","removeChild","CustomEvent","completeEvent","focus","selection","setSelectionRange","start","end","direction","serverNodeContext","serverNodeKey","className","replace","trim","selector","tagName","id","rootClientNode","clientNodes","querySelectorAll","log","item","initAll","opts","theWindow","data","_document","currentScript","slice","getElementsByTagName","eventSelectors","getAppRoot","map","eventSelector","hasOwnProperty","replay","handleEvents","createOverlay","overlay","createElement","setAttribute","documentElement","appendChild","buffer","createBuffer","disableOverlay","serverRoot","createListenHandler","addEventListener","CARET_EVENTS","CARET_NODES","matches","msMatchesSelector","target","keyCodes","filter","keyCode","which","preventDefault","action","indexOf","isCaretNode","getSelection","undefined","freeze","overlay_1","name","nodeValue","selectionStart","selectionEnd","selectionDirection","body","cloneNode","insertBefore","eventRecorder","initFunctionName","defaultOptions","getEventRecorderCode","eventRecorderFunctions","funcName","fnCleaned","toString","join","getInlineDefinition","customOptions","assign","validateOptions","scriptCode","optsStr","stringifyWithFunctions","getInlineInvocation","appRoot","Error","optionSets","_i","arguments","output","index","source","nextKey","obj","stopFuncIdx","fn","FUNC_START","FUNC_STOP","str","JSON","stringify","_key","constructor","apply","startFuncIdx","substring","PREBOOT_SCRIPT_CLASS","PREBOOT_OPTIONS","createScriptFromCode","nonce","inlineCode","script","textContent","PREBOOT_FACTORY","prebootOpts","platformId","appRef","eventReplayer","isPlatformServer","inlineCodeDefinition","scriptWithDefinition","existingScripts","getElementsByClassName","appRootSelectors","concat","head","appRootElem","querySelector","_a","scriptWithInvocation","firstChild","isPlatformBrowser","isStable","pipe","stable","take","subscribe","PREBOOT_PROVIDER","provide","APP_BOOTSTRAP_LISTENER","useFactory","deps","DOCUMENT","Optional","Inject","PLATFORM_ID","ApplicationRef","multi","PrebootModule","withConfig","ngModule","providers","useValue","NgModule","args"],"mappings":"+dAYgBA,EAAqBC,GAOnC,IANA,IAAMC,EAAuB,GACvBC,EAAOF,EAAYE,KACnBC,EAAOH,EAAYG,KACrBC,EAAuBD,EAGpBC,GAAQA,IAASF,EAAKG,YAAcD,IAASF,EAAKI,YACvDL,EAAUM,KAAKH,GACfA,EAAOA,EAAKI,WAIVJ,GACFH,EAAUM,KAAKH,GASjB,IAJA,IACIK,EADSN,EAAKO,UAAY,UAIrBC,EAFGV,EAAUW,OAEH,EAAGD,GAAK,EAAGA,IAG5B,IAFAP,EAAOH,EAAUU,IAERE,YAAcF,EAAI,EACzB,IAAK,IAAIG,EAAI,EAAGC,EAAI,EAAGD,EAAIV,EAAKS,WAAWD,OAAQE,IAKjD,GAHoC,IAAhCV,EAAKS,WAAWC,GAAGE,UACrBD,IAEEX,EAAKS,WAAWC,KAAOb,EAAUU,EAAI,GAAI,CAC3CF,GAAO,KAAOM,EACd,MAMR,OAAON;;;;;;;WC3CIQ,EAAgB,IAAIC,EAAAA,eAAuB;;;;;;;;;;;;;;;;;;;;;oFCkG3BC,OAAOC,gBAYpBC,EAASC,GACrB,IAAIC,EAAsB,mBAAXC,QAAyBA,OAAOC,SAAUC,EAAIH,GAAKD,EAAEC,GAAIZ,EAAI,EAC5E,GAAIe,EAAG,OAAOA,EAAEC,KAAKL,GACrB,GAAIA,GAAyB,iBAAbA,EAAEV,OAAqB,MAAO,CAC1CgB,KAAM,WAEF,OADIN,GAAKX,GAAKW,EAAEV,SAAQU,OAAI,GACrB,CAAEO,MAAOP,GAAKA,EAAEX,KAAMmB,MAAOR,KAG5C,MAAM,IAAIS,UAAUR,EAAI,0BAA4B,mCA6E/BJ,OAAOC,gBC5LhBY,IACd,MAAO,CACLC,YAAcC,OAA4B,YAC1CC,iBAAkBD,OAAOC,iBACzBC,SAAUA,2BAId,SAAAC,IACEC,KAAAC,gBAA8C,GAC9CD,KAAAE,eAAgB,SAOhBH,EAAAI,UAAAC,UAAA,SAAUC,GACRL,KAAKK,IAAMA,GAObN,EAAAI,UAAAG,UAAA,WAIE,OAHKN,KAAKK,MACRL,KAAKK,IAAMX,KAENM,KAAKK,KAOdN,EAAAI,UAAAI,UAAA,WAAA,IAAAC,EAAAR,KACE,IAAIA,KAAKE,cAAT,CAGEF,KAAKE,eAAgB,EAIvB,IAAMP,EAAcK,KAAKM,YAAYX,aAAe,IACvCA,EAAYc,MAAQ,IAC5BC,SAAQ,SAAAC,GAAW,OAAAH,EAAKI,aAAaD,MAG1CX,KAAKa,QAAQlB,KAOfI,EAAAI,UAAAS,aAAA,SAAaD,GAAb,IAAAH,EAAAR,KACEW,EAA2BA,GAAW,GAGtC,KACiBA,EAAQG,QAAU,IAG1BJ,SAAQ,SAAAK,GAAS,OAAAP,EAAKQ,YAAYL,EAASI,MAClD,MAAOE,GACPC,QAAQC,MAAMF,GAIhBjB,KAAKoB,aAAaT,IAQpBZ,EAAAI,UAAAa,YAAA,SAAYL,EAAyBU,GACnCV,EAA2BA,GAAW,GAGtC,IAAMI,GAFNM,EAA8BA,GAAgB,IAEnBN,MACrBhD,EAAasD,EAAaxD,MAAQ,GAClCyD,EAAUD,EAAaC,QACvBtD,EAAagC,KAAKuB,eAAe,CACrC3D,KAAM+C,EAAQ/C,KACdC,KAAME,EACNuD,QAASA,IAINtD,GASJA,EAAgCwD,QAAUzD,EAAWyD,QACrDxD,EAAiCyD,SAAW1D,EAAW0D,SACvDzD,EAAiCuB,MAAQxB,EAAWwB,MACrDvB,EAAW0D,cAAcX,IAXvBG,QAAQS,KACN,4BAA4BZ,EAAMa,KAAI,YAAYN,EAAO,6DACPvD,IAiBxDgC,EAAAI,UAAAiB,aAAA,SAAaT,GAGX,IAAM/C,GAFN+C,EAA2BA,GAAW,IAEE/C,MAAQ,GAC1CiE,EAAajE,EAAKG,WAClB+D,EAAalE,EAAKI,WAIxB,GAAK8D,GAAeD,GAAcA,IAAeC,GAAsC,SAAxBD,EAAWzD,SAK1E,IAEE,IACM2D,GAAUC,EADJhC,KAAKM,YAAYT,kBACTgC,GAAYI,iBAAiB,YAAc,QAG/DJ,EAAWK,OAASL,EAAWK,SAAYL,EAAWM,MAAMJ,QAAU,OAGtED,EAAWK,MAAMJ,QAAUA,EAC3B,MAAOd,GACPC,QAAQC,MAAMF,KASlBlB,EAAAI,UAAAU,QAAA,SAAQlB,WAARa,EAAAR,KAGQoC,GAFNzC,EAAcA,GAAe,IAECyC,WAAa,GAIrCC,EAAa1C,EAAY0C,WACb,MAAdA,GACFC,YAAW,WAAM,OAAA9B,EAAK+B,SAASF,KAAa,OAI9C,IAAuB,IAAAG,EAAAzD,EAAAqD,GAASK,EAAAD,EAAAlD,QAAAmD,EAAAjD,KAAAiD,EAAAD,EAAAlD,OAAE,CAA7B,IAAMoD,EAAQD,EAAAlD,MACjBmD,EAAS7E,KAAK8E,oBAAoBD,EAASE,UAAWF,EAASG,2GAIjE,IAAMC,EAAM9C,KAAKM,YAAYR,SACvBiD,EAAiBD,EAAIE,eAAe,kBAe1C,GAdID,IACFA,EAAeb,OACba,EAAeb,SAAyC,OAA9Ba,EAAe7E,WACzC6E,EAAe7E,WAAW+E,YAAYF,GACtCA,EAAeZ,MAAMJ,QAAU,QAInCpC,EAAYc,KAAO,GACnBT,KAAKC,gBAAkB,GAKI,mBAAhBiD,YAA4B,CACrC,IAAMC,EAAgB,IAAID,YAAY,mBACtCJ,EAAIpB,cAAcyB,QAElBjC,QAAQS,KAAK,gHAKjB5B,EAAAI,UAAAoC,SAAA,SAASF,GAEP,GAAKA,GAAeA,EAAWxE,MAASwE,EAAWf,QAAnD,CAKA,IAAMtD,EAAagC,KAAKuB,eAAec,GACvC,GAAIrE,EAAY,CAEdA,EAAWoF,QAGX,IAAMC,EAAYhB,EAAWgB,UAC7B,GAAKrF,EAAgCsF,mBAAqBD,EACxD,IACGrF,EACEsF,kBAAkBD,EAAUE,MAAOF,EAAUG,IAAKH,EAAUI,WAC/D,MAAOxC,QAoBflB,EAAAI,UAAAoB,eAAA,SAAemC,GAGb,IAAM3F,GAFN2F,EAAkCA,GAAqB,IAElB7F,KAC/BD,EAAO8F,EAAkB9F,KAG/B,IAAKA,IAASA,EAAKG,aAAeH,EAAKI,WACrC,OAAO,KAKT,IAAM2F,EAAgBD,EAAkBpC,SAAW7D,EAAqBiG,GAGxE,GAAI1D,KAAKC,gBAAgB0D,GACvB,OAAO3D,KAAKC,gBAAgB0D,GAI9B,IAAMC,GAAa7F,EAAW6F,WAAa,IAAIC,QAAQ,aAAc,IAAIC,OACrEC,EAAWhG,EAAWiG,QAEtBjG,EAAWkG,GACbF,GAAY,IAAIhG,EAAWkG,GAClBL,IACTG,GAAY,IAAIH,EAAUC,QAAQ,KAAM,MAK1C,IAAMK,EAAiBtG,EAAKI,WACxBmG,EAAcD,EAAeE,iBAAiBL,GAG7CI,EAAY7F,SACf4C,QAAQmD,IAAI,qBAAqBN,EAAQ,aAAahG,EAAWiG,SACjEG,EAAcD,EAAeE,iBAAiBrG,EAAWiG,UAI3D,IADA,IAAM1F,EAAS6F,EAAY7F,OAClBD,EAAI,EAAGA,EAAIC,EAAQD,IAAK,CAC/B,IAAML,EAAamG,EAAYG,KAAKjG,GAUpC,GAPsBZ,EAAqB,CACzCG,KAAMA,EACNC,KAAMG,MAKc2F,EAEpB,OADA3D,KAAKC,gBAAgB0D,GAAiB3F,EAC/BA,EAKX,OAA2B,IAAvBmG,EAAY7F,QACd0B,KAAKC,gBAAgB0D,GAAiBQ,EAAY,GAC3CA,EAAY,KAKrBjD,QAAQS,KACN,qCAAqCgC,EAAa,+EAG7C,qBCjSKY,EAAQC,EAAsBnE,GAC5C,IAAMoE,EAA4BpE,GAAOT,OAMnC8E,EAAQD,EAAU9E,YAA2B,CACjD6E,KAAMA,EACN/D,KAAM,GACN2B,UAAW,IAGb,OAAO,WAAM,OAAAmB,EAAMmB,EAAMD,aAYXlB,EAAM5D,EAA0BU,GAC9C,IACMsE,GAD4BtE,GAAOT,QACFE,UAAY,GAK7C8E,EAAgBD,EAAUC,eAK9B,GAAGC,MAAMxF,KAAKsF,EAAUG,qBAAqB,WAAY,GAAG,GAE9D,GAAKF,EAAL,CAKA,IAAI7G,EAAa6G,EAAc1G,WAC/B,GAAKH,EAAL,CAKAA,EAAWkF,YAAY2B,GAEvB,IACIG,GADSpF,EAAY6E,MAAS,IACRO,gBAAkB,GAOtCpE,EAA0B,CAAE/C,KAJlB+B,EAAY6E,KAAOQ,EAAWL,EAAWhF,EAAY6E,KAAMzG,GAAc,KAIxC+C,OAAQ,IACrDnB,EAAYc,MACdd,EAAYc,KAAKxC,KAAK0C,IAGxBoE,EAAiBA,EAAeE,KAAI,SAAAC,GAIlC,OAHKA,EAAcC,eAAe,YAChCD,EAAcE,QAAS,GAElBF,MAIMxE,SAAQ,SAAAwE,GACrB,OAAAG,EAAaV,EAAWhF,EAAagB,EAASuE,WA5B9ChE,QAAQC,MAAM,8DANdD,QAAQC,MAAM,+EA4CFmE,EAAcX,GAC5B,IAAIY,EAAUZ,EAAUa,cAAc,OAStC,OARAD,EAAQE,aAAa,KAAM,kBAC3BF,EAAQE,aACN,QACA,iHAGFd,EAAUe,gBAAgBC,YAAYJ,GAE/BA,WAcOP,EACdL,EACAH,EACAzG,GAEA,IAAMH,EAAyB,CAACG,WAAUA,GAW1C,OAPAH,EAAKI,WAAawG,EAAKoB,OAASC,EAAajI,GAAQA,EAAKG,WAGrDyG,EAAKsB,iBACRlI,EAAK2H,QAAUD,EAAcX,IAGxB/G,WAWOyH,EAAaV,EACAhF,EACAgB,EACAuE,GAC3B,IAAMa,EAAapF,EAAQ/C,KAAKG,WAG3BgI,GAOLb,EAAcpE,OAAOJ,SAAQ,SAACkC,GAE5B,IAAMC,EAAUmD,EAAoBrB,EAAWhF,EAAauF,EAAevE,GAG3EoF,EAAWE,iBAAiBrD,EAAWC,GAAS,GAI5ClD,EAAYyC,WACdzC,EAAYyC,UAAUnE,KAAK,CACzBJ,KAAMkI,EACNnD,UAASA,EACTC,QAAOA,gBASCmD,EACdrB,EACAhF,EACAuF,EACAvE,GAEA,IAAMuF,EAAe,CAAC,QAAS,UAAW,UAAW,UAAW,aAC1DC,EAAc,CAAC,QAAS,YAIxBC,EAAUzB,EAAUe,gBAAgBU,SACvCzB,EAAUe,gBAAwBW,kBAC/B7B,EAAO7E,EAAY6E,KAEzB,OAAO,SAASzD,GACd,IAAMlD,EAAgBkD,EAAMuF,OAI5B,GAAKF,EAAQ/G,KAAKxB,EAAMqH,EAAcnB,UAAtC,CAIA,IAAMnG,EAAO+C,EAAQ/C,KACfgF,EAAY7B,EAAMa,KAGxB,GAAK/D,GAAS+E,EAAd,CAMA,IAAM2D,EAAWrB,EAAcqB,SAC/B,GAAIA,GAAYA,EAASjI,OAKvB,IAJyBiI,EAASC,QAAO,SAAAC,GAAW,OAAA1F,EAAM2F,QAAUD,KAI9CnI,OACpB,OAKA4G,EAAcyB,gBAChB5F,EAAM4F,iBAIJzB,EAAc0B,QAChB1B,EAAc0B,OAAO/I,EAAMkD,GAI7B,IAAMO,EAAU7D,EAAqB,CAAEG,KAAMA,EAAMC,KAAMA,IAGzD,GAAIqI,EAAaW,QAAQjE,IAAc,EAAG,CAExC,IAAMkE,EAAcX,EAAYU,QAAQhJ,EAAKmG,QAAUnG,EAAKmG,QAAU,KAAO,EAE7ErE,EAAY0C,WAAa,CACvBzE,KAAMA,EACNC,KAAMA,EACNyD,QAASA,EACT+B,UAAWyD,EAAcC,EAAalJ,QAA4BmJ,OAE7C,WAAdpE,GAAwC,aAAdA,IACnCjD,EAAY0C,gBAAa2E,GAI3B,GAAIxC,IAASA,EAAKsB,gBAAkBZ,EAAc+B,OAAQ,CACxD,IAAMC,EAAUtJ,EAAK2H,QAGrB2B,EAAQ/E,MAAMJ,QAAU,QAIxBO,YAAW,WACT4E,EAAQ/E,MAAMJ,QAAU,SACvB,KAKDmD,EAAcE,QAChBzE,EAAQG,OAAO7C,KAAK,CAClBJ,KAAIA,EACJyD,QAAOA,EACPP,MAAKA,EACLoG,KAAMvE,gBAUEmE,EAAalJ,GAG3B,IAAMuJ,GAFNvJ,EAAOA,GAAQ,IAEQ0B,OAAS,GAC1B8D,EAA8B,CAClCE,MAAO6D,EAAU9I,OACjBkF,IAAK4D,EAAU9I,OACfmF,UAAW,WAIb,KACM5F,EAAKwJ,gBAA0C,IAAxBxJ,EAAKwJ,kBAC9BhE,EAAUE,MAAQ1F,EAAKwJ,eACvBhE,EAAUG,IAAM3F,EAAKyJ,aAAezJ,EAAKyJ,aAAe,EACxDjE,EAAUI,UAAY5F,EAAK0J,mBACzB1J,EAAK0J,mBAAkD,QAE3D,MAAOtG,IAET,OAAOoC,WASOwC,EAAajI,GAC3B,IAAMG,EAAaH,EAAKG,WAIxB,IAAKA,IAAeA,EAAWG,YAC7BH,IAAe+B,SAAS4F,iBAAmB3H,IAAe+B,SAAS0H,KACnE,OAAOzJ,EAIT,IAAMmG,EAAiBnG,EAAW0J,WAAU,GAY5C,OATAvD,EAAe/B,MAAMJ,QAAU,OAG/BhE,EAAWG,WAAWwJ,aAAaxD,EAAgBnG,GAGnDA,EAAW0H,aAAa,kBAAmB,IAGpCvB,EC5UT,IAAMyD,EAAgB,CACpBpE,MAAKA,EACL+B,cAAaA,EACbN,WAAUA,EACVK,aAAYA,EACZW,oBAAmBA,EACnBe,aAAYA,EACZlB,aAAYA,GAGD+B,EAAmB,gBAInBC,EAAiC,CAC5CjC,QAAQ,EACRR,QAAQ,EACRU,gBAAgB,EAIhBf,eAAgB,CAEd,CACEhB,SAAU,iBACVjD,OAAQ,CAAC,WAAY,QAAS,UAAW,QAAS,WAEpD,CAAEiD,SAAU,gBAAiBjD,OAAQ,CAAC,WAGtC,CACEiD,SAAU,QACVjD,OAAQ,CAAC,SACT6F,gBAAgB,EAChBJ,SAAU,CAAC,IACXU,QAAQ,GAIV,CACElD,SAAU,OACVjD,OAAQ,CAAC,UACT6F,gBAAgB,EAChBM,QAAQ,GAIV,CACElD,SAAU,iBACVjD,OAAQ,CAAC,UAAW,WAAY,YAAa,WAC7CsE,QAAQ,GAIV,CACErB,SAAU,SACVjD,OAAQ,CAAC,SACT6F,gBAAgB,EAChBM,QAAQ,cASEa,IACd,IAAMC,EAAmC,GAEzC,IAAK,IAAMC,KAAYL,EACrB,GAAIA,EAAcxC,eAAe6C,GAAW,CAC1C,IACMC,EADWN,EAAeK,GAAUE,WACrBrE,QAAQ,YAAa,IAC1CkE,EAAuB9J,KAAKgK,GAQhC,OAHAF,EAAuB9J,KAAKR,EAAqByK,YAG1C,OAASH,EAAuBI,KAAK,QAAU,gBAaxCC,EAAoBC,GAClC,IAAM7D,EAAuB8D,EAAO,GAAIT,EAAgBQ,GAGxDE,EAAgB/D,GAEhB,IAAMgE,EAAaV,IACbW,EAAUC,EAAuBlE,GAIvC,MAAO,4CACDgE,EAAU,mBAFGjE,EAAQ2D,WAGFrE,QAAQ,YAAa,IAAG,KAAK4E,EAAO,yBAe/CE,IACd,MAAUf,4BAOIW,EAAgB/D,GAC9B,IAAKA,EAAKoE,UAAYpE,EAAKoE,QAAQtK,OACjC,MAAM,IAAIuK,MACR,uMAgBUP,EAAOhC,OAAgB,IAAAwC,EAAA,GAAAC,EAAA,EAAAA,EAAAC,UAAA1K,OAAAyK,IAAAD,EAAAC,EAAA,GAAAC,UAAAD,GACrC,GAAIzC,MAAAA,EACF,MAAM,IAAI7G,UAAU,8CAItB,IADA,IAAMwJ,EAASpK,OAAOyH,GACb4C,EAAQ,EAAGA,EAAQJ,EAAWxK,OAAQ4K,IAAS,CACtD,IAAMC,EAASL,EAAWI,GAC1B,GAAIC,MAAAA,EACF,IAAK,IAAMC,KAAWD,EAChBA,EAAOhE,gBAAkBgE,EAAOhE,eAAeiE,KACjDH,EAAOG,GAAWD,EAAOC,IAMjC,OAAOH,WAYOP,EAAuBW,GAkBrC,IAjBA,IAeIC,EACAC,EAhBEC,EAAa,sBACbC,EAAY,qBAGdC,EAAMC,KAAKC,UAAUP,GAAK,SAASQ,EAAMtK,GAE3C,OAAOA,GAASA,EAAMuK,aAAevK,EAAMF,MAAQE,EAAMwK,MAChDP,EAAajK,EAAM2I,WAAauB,EAEhClK,KAKPyK,EAAeN,EAAI7C,QAAQ2C,GAGxBQ,GAAgB,GACrBV,EAAcI,EAAI7C,QAAQ4C,GAI1BF,GADAA,EAAKG,EAAIO,UAAUD,EAAeR,EAAWlL,OAAQgL,IAC7CzF,QAAQ,OAAQ,MAIxBmG,GAFAN,EAAMA,EAAIO,UAAU,EAAGD,EAAe,GAAKT,EACzCG,EAAIO,UAAUX,EAAcG,EAAUnL,OAAS,IAC9BuI,QAAQ2C,GAG7B,OAAOE;;;;;;;;;;;;;;OC9MT,IAAMQ,EAAuB,wBAChBC,EAAkB,IAAIvL,EAAAA,eAA+B,kBAElE,SAASwL,EAAqBtH,EAAeuH,EAAoBC,GAC/D,IAAMC,EAASzH,EAAI0C,cAAc,UAOjC,OANI6E,IACDE,EAAeF,MAAQA,GAE1BE,EAAO3G,UAAYsG,EACnBK,EAAOC,YAAcF,EAEdC,WAGOE,EAAgB3H,EACA4H,EACAL,EACAM,EACAC,EACAC,GAC9B,OAAO,WAGL,GAFAtC,EAAgBmC,GAEZI,EAAAA,iBAAiBH,GAAa,CAChC,IAAMI,EAAuB3C,EAAoBsC,GAC3CM,EAAuBZ,EAAqBtH,EAAKuH,EAAOU,GAGxDE,EAAkBnI,EAAIoI,uBAAuBhB,GAInD,GAA+B,IAA3Be,EAAgB3M,OAAc,CAChC,IACM6M,EADqB,GACOC,OAAOV,EAAY9B,SACrD9F,EAAIuI,KAAK1F,YAAYqF,GACrBG,EACGlG,KAAI,SAAAlB,GAAY,MAAA,CACfA,SAAQA,EACRuH,YAAaxI,EAAIyI,cAAcxH,OAEhCrD,SAAQ,SAAC8K,OAACzH,EAAQyH,EAAAzH,SAAEuH,EAAWE,EAAAF,YAC9B,GAAKA,EAAL,CAIA,IAAMG,EAAuBrB,EAAqBtH,EAAKuH,ED2EvDzC,oBC1EA0D,EAAY5D,aAAa+D,EAAsBH,EAAYI,iBAJzDxK,QAAQmD,IAAI,sCAAsCN,WAM/CkH,EAAgB3M,OAAS,GAAK+L,IACtCY,EAAgB,GAAWZ,MAAQA,GAGpCsB,EAAAA,kBAAkBhB,MACiB,MAAtBD,EAAYtF,QAAiBsF,EAAYtF,SAEtDwF,EAAOgB,SACJC,KACCrF,EAAAA,QAAO,SAAAsF,GAAU,OAAAA,KACjBC,EAAAA,KAAK,IACLC,WAAU,WACZnB,EAActK,qBAOX0L,EAAmB,CAC9BC,QAAqCC,EAAAA,uBACrCC,WAAY3B,EACZ4B,KAAM,CACJC,EAAAA,SACAnC,EACA,CAAC,IAAIoC,EAAAA,SAAY,IAAIC,EAAAA,OAAO7N,IAC5B8N,EAAAA,YACAC,EAAAA,eACA3M,GAEF4M,OAAO,gBCvFT,SAAAC,YACSA,EAAAC,WAAP,SAAkBrI,GAChB,MAAO,CACLsI,SAAUF,EACVG,UAAW,CAAC,CAACb,QAAS/B,EAAiB6C,SAAUxI;;;;;;;2BAPtDyI,EAAAA,SAAQC,KAAA,CAAC,CACRH,UAAW,CAAChN,EAAekM","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { NodeContext } from './preboot.interfaces';\n\n/**\n * Attempt to generate key from node position in the DOM\n */\nexport function getNodeKeyForPreboot(nodeContext: NodeContext): string {\n  const ancestors: Element[] = [];\n  const root = nodeContext.root;\n  const node = nodeContext.node;\n  let temp: Element | null = node;\n\n  // walk up the tree from the target node up to the root\n  while (temp && temp !== root.serverNode && temp !== root.clientNode) {\n    ancestors.push(temp);\n    temp = temp.parentNode as Element;\n  }\n\n  // note: if temp doesn't exist here it means root node wasn't found\n  if (temp) {\n    ancestors.push(temp);\n  }\n\n  // now go backwards starting from the root, appending the appName to unique\n  // identify the node later..\n  const name = node.nodeName || 'unknown';\n  let key = name;\n  const len = ancestors.length;\n\n  for (let i = len - 1; i >= 0; i--) {\n    temp = ancestors[i];\n\n    if (temp.childNodes && i > 0) {\n      for (let j = 0, n = 0; j < temp.childNodes.length; j++) {\n        // Node is not a comment node\n        if (temp.childNodes[j].nodeType !== 8) {\n          n++;\n        }\n        if (temp.childNodes[j] === ancestors[i - 1]) {\n          key += '_s' + n;\n          break;\n        }\n      }\n    }\n  }\n\n  return key;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {InjectionToken} from '@angular/core';\n\nexport const PREBOOT_NONCE = new InjectionToken<string>('PrebootNonce');\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  NodeContext,\n  PrebootAppData,\n  PrebootData,\n  PrebootEvent,\n  PrebootWindow,\n  ServerClientRoot,\n} from '../common/preboot.interfaces';\nimport {getNodeKeyForPreboot} from '../common/get-node-key';\n\nexport function _window(): PrebootWindow {\n  return {\n    prebootData: (window as any)['prebootData'],\n    getComputedStyle: window.getComputedStyle,\n    document: document\n  };\n}\n\nexport class EventReplayer {\n  clientNodeCache: { [key: string]: Element } = {};\n  replayStarted = false;\n  win: PrebootWindow;\n\n  /**\n   * Window setting and getter to facilitate testing of window\n   * in non-browser environments\n   */\n  setWindow(win: PrebootWindow) {\n    this.win = win;\n  }\n\n  /**\n   * Window setting and getter to facilitate testing of window\n   * in non-browser environments\n   */\n  getWindow() {\n    if (!this.win) {\n      this.win = _window();\n    }\n    return this.win;\n  }\n\n  /**\n   * Replay all events for all apps. this can only be run once.\n   * if called multiple times, will only do something once\n   */\n  replayAll() {\n    if (this.replayStarted) {\n      return;\n    } else {\n      this.replayStarted = true;\n    }\n\n    // loop through each of the preboot apps\n    const prebootData = this.getWindow().prebootData || {};\n    const apps = prebootData.apps || [];\n    apps.forEach(appData => this.replayForApp(appData));\n\n    // once all events have been replayed and buffers switched, then we cleanup preboot\n    this.cleanup(prebootData);\n  }\n\n  /**\n   * Replay all events for one app (most of the time there is just one app)\n   * @param appData\n   */\n  replayForApp(appData: PrebootAppData) {\n    appData = <PrebootAppData>(appData || {});\n\n    // try catch around events b/c even if error occurs, we still move forward\n    try {\n      const events = appData.events || [];\n\n      // replay all the events from the server view onto the client view\n      events.forEach(event => this.replayEvent(appData, event));\n    } catch (ex) {\n      console.error(ex);\n    }\n\n    // if we are buffering, switch the buffers\n    this.switchBuffer(appData);\n  }\n\n  /**\n   * Replay one particular event\n   * @param appData\n   * @param prebootEvent\n   */\n  replayEvent(appData: PrebootAppData, prebootEvent: PrebootEvent) {\n    appData = <PrebootAppData>(appData || {});\n    prebootEvent = <PrebootEvent>(prebootEvent || {});\n\n    const event = prebootEvent.event as Event;\n    const serverNode = prebootEvent.node || {};\n    const nodeKey = prebootEvent.nodeKey;\n    const clientNode = this.findClientNode({\n      root: appData.root,\n      node: serverNode,\n      nodeKey: nodeKey\n    });\n\n    // if client node can't be found, log a warning\n    if (!clientNode) {\n      console.warn(\n        `Trying to dispatch event ${event.type} to node ${nodeKey}\n        but could not find client node. Server node is: ${serverNode}`\n      );\n      return;\n    }\n\n    // now dispatch events and whatnot to the client node\n    (clientNode as HTMLInputElement).checked = serverNode.checked;\n    (clientNode as HTMLOptionElement).selected = serverNode.selected;\n    (clientNode as HTMLOptionElement).value = serverNode.value;\n    clientNode.dispatchEvent(event);\n  }\n\n  /**\n   * Switch the buffer for one particular app (i.e. display the client\n   * view and destroy the server view)\n   * @param appData\n   */\n  switchBuffer(appData: PrebootAppData) {\n    appData = <PrebootAppData>(appData || {});\n\n    const root = <ServerClientRoot>(appData.root || {});\n    const serverView = root.serverNode;\n    const clientView = root.clientNode;\n\n    // if no client view or the server view is the body or client\n    // and server view are the same, then don't do anything and return\n    if (!clientView || !serverView || serverView === clientView || serverView.nodeName === 'BODY') {\n      return;\n    }\n\n    // do a try-catch just in case something messed up\n    try {\n      // get the server view display mode\n      const gcs = this.getWindow().getComputedStyle;\n      const display = gcs(serverView).getPropertyValue('display') || 'block';\n\n      // first remove the server view\n      serverView.remove ? serverView.remove() : (serverView.style.display = 'none');\n\n      // now add the client view\n      clientView.style.display = display;\n    } catch (ex) {\n      console.error(ex);\n    }\n  }\n\n  /**\n   * Finally, set focus, remove all the event listeners and remove\n   * any freeze screen that may be there\n   * @param prebootData\n   */\n  cleanup(prebootData: PrebootData) {\n    prebootData = prebootData || {};\n\n    const listeners = prebootData.listeners || [];\n\n    // set focus on the active node AFTER a small delay to ensure buffer\n    // switched\n    const activeNode = prebootData.activeNode;\n    if (activeNode != null) {\n      setTimeout(() => this.setFocus(activeNode), 1);\n    }\n\n    // remove all event listeners\n    for (const listener of listeners) {\n      listener.node.removeEventListener(listener.eventName, listener.handler);\n    }\n\n    // remove the freeze overlay if it exists\n    const doc = this.getWindow().document;\n    const prebootOverlay = doc.getElementById('prebootOverlay');\n    if (prebootOverlay) {\n      prebootOverlay.remove ?\n        prebootOverlay.remove() : prebootOverlay.parentNode !== null ?\n        prebootOverlay.parentNode.removeChild(prebootOverlay) :\n        prebootOverlay.style.display = 'none';\n    }\n\n    // clear out the data stored for each app\n    prebootData.apps = [];\n    this.clientNodeCache = {};\n\n    // send event to document that signals preboot complete\n    // constructor is not supported by older browsers ( i.e. IE9-11 )\n    // in these browsers, the type of CustomEvent will be \"object\"\n    if (typeof CustomEvent === 'function') {\n      const completeEvent = new CustomEvent('PrebootComplete');\n      doc.dispatchEvent(completeEvent);\n    } else {\n      console.warn(`Could not dispatch PrebootComplete event.\n       You can fix this by including a polyfill for CustomEvent.`);\n    }\n  }\n\n  setFocus(activeNode: NodeContext) {\n    // only do something if there is an active node\n    if (!activeNode || !activeNode.node || !activeNode.nodeKey) {\n      return;\n    }\n\n    // find the client node in the new client view\n    const clientNode = this.findClientNode(activeNode);\n    if (clientNode) {\n      // set focus on the client node\n      clientNode.focus();\n\n      // set selection if a modern browser (i.e. IE9+, etc.)\n      const selection = activeNode.selection;\n      if ((clientNode as HTMLInputElement).setSelectionRange && selection) {\n        try {\n          (clientNode as HTMLInputElement)\n            .setSelectionRange(selection.start, selection.end, selection.direction);\n        } catch (ex) {}\n      }\n    }\n  }\n\n  /**\n   * Given a node from the server rendered view, find the equivalent\n   * node in the client rendered view. We do this by the following approach:\n   *      1. take the name of the server node tag (ex. div or h1 or input)\n   *      2. add either id (ex. div#myid) or class names (ex. div.class1.class2)\n   *      3. use that value as a selector to get all the matching client nodes\n   *      4. loop through all client nodes found and for each generate a key value\n   *      5. compare the client key to the server key; once there is a match,\n   *          we have our client node\n   *\n   * NOTE: this only works when the client view is almost exactly the same as\n   * the server view. we will need an improvement here in the future to account\n   * for situations where the client view is different in structure from the\n   * server view\n   */\n  findClientNode(serverNodeContext: NodeContext): HTMLElement | null {\n    serverNodeContext = <NodeContext>(serverNodeContext || {});\n\n    const serverNode = serverNodeContext.node;\n    const root = serverNodeContext.root;\n\n    // if no server or client root, don't do anything\n    if (!root || !root.serverNode || !root.clientNode) {\n      return null;\n    }\n\n    // we use the string of the node to compare to the client node & as key in\n    // cache\n    const serverNodeKey = serverNodeContext.nodeKey || getNodeKeyForPreboot(serverNodeContext);\n\n    // if client node already in cache, return it\n    if (this.clientNodeCache[serverNodeKey]) {\n      return this.clientNodeCache[serverNodeKey] as HTMLElement;\n    }\n\n    // get the selector for client nodes\n    const className = (serverNode.className || '').replace('ng-binding', '').trim();\n    let selector = serverNode.tagName;\n\n    if (serverNode.id) {\n      selector += `#${serverNode.id}`;\n    } else if (className) {\n      selector += `.${className.replace(/ /g, '.')}`;\n    }\n\n    // select all possible client nodes and look through them to try and find a\n    // match\n    const rootClientNode = root.clientNode;\n    let clientNodes = rootClientNode.querySelectorAll(selector);\n\n    // if nothing found, then just try the tag name as a final option\n    if (!clientNodes.length) {\n      console.log(`nothing found for ${selector} so using ${serverNode.tagName}`);\n      clientNodes = rootClientNode.querySelectorAll(serverNode.tagName);\n    }\n\n    const length = clientNodes.length;\n    for (let i = 0; i < length; i++) {\n      const clientNode = clientNodes.item(i);\n\n      // get the key for the client node\n      const clientNodeKey = getNodeKeyForPreboot({\n        root: root,\n        node: clientNode\n      });\n\n      // if the client node key is exact match for the server node key, then we\n      // found the client node\n      if (clientNodeKey === serverNodeKey) {\n        this.clientNodeCache[serverNodeKey] = clientNode;\n        return clientNode as HTMLElement;\n      }\n    }\n\n    // if we get here and there is one clientNode, use it as a fallback\n    if (clientNodes.length === 1) {\n      this.clientNodeCache[serverNodeKey] = clientNodes[0];\n      return clientNodes[0] as HTMLElement;\n    }\n\n    // if we get here it means we couldn't find the client node so give the user\n    // a warning\n    console.warn(\n      `No matching client node found for ${serverNodeKey}.\n       You can fix this by assigning this element a unique id attribute.`\n    );\n    return null;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  EventSelector,\n  PrebootOptions,\n  PrebootAppData,\n  PrebootData,\n  DomEvent,\n  PrebootWindow,\n  ServerClientRoot,\n  PrebootSelection,\n  PrebootSelectionDirection,\n} from '../common/preboot.interfaces';\nimport {getNodeKeyForPreboot} from '../common/get-node-key';\n\n/**\n * Called right away to initialize preboot\n *\n * @param opts All the preboot options\n * @param win\n */\nexport function initAll(opts: PrebootOptions, win?: PrebootWindow) {\n  const theWindow = <PrebootWindow>(win || window);\n\n  // Add the preboot options to the preboot data and then add the data to\n  // the window so it can be used later by the client.\n  // Only set new options if they're not already set - we may have multiple app roots\n  // and each of them invokes the init function separately.\n  const data = (theWindow.prebootData = <PrebootData>{\n    opts: opts,\n    apps: [],\n    listeners: []\n  });\n\n  return () => start(data, theWindow);\n}\n\n/**\n * Start up preboot by going through each app and assigning the appropriate\n * handlers. Normally this wouldn't be called directly, but we have set it up so\n * that it can for older versions of Universal.\n *\n * @param prebootData Global preboot data object that contains options and will\n * have events\n * @param win Optional param to pass in mock window for testing purposes\n */\nexport function start(prebootData: PrebootData, win?: PrebootWindow) {\n  const theWindow = <PrebootWindow>(win || window);\n  const _document = <Document>(theWindow.document || {});\n\n  // Remove the current script from the DOM so that child indexes match\n  // between the client & the server. The script is already running so it\n  // doesn't affect it.\n  const currentScript = _document.currentScript ||\n    // Support: IE 9-11 only\n    // IE doesn't support document.currentScript. Since the script is invoked\n    // synchronously, though, the current running script is just the last one\n    // currently in the document.\n    [].slice.call(_document.getElementsByTagName('script'), -1)[0];\n\n  if (!currentScript) {\n    console.error('Preboot initialization failed, no currentScript has been detected.');\n    return;\n  }\n\n  let serverNode = currentScript.parentNode;\n  if (!serverNode) {\n    console.error('Preboot initialization failed, the script is detached');\n    return;\n  }\n\n  serverNode.removeChild(currentScript);\n\n  const opts = prebootData.opts || ({} as PrebootOptions);\n  let eventSelectors = opts.eventSelectors || [];\n\n  // get the root info\n  const appRoot = prebootData.opts ? getAppRoot(_document, prebootData.opts, serverNode) : null;\n\n  // we track all events for each app in the prebootData object which is on\n  // the global scope; each `start` invocation adds data for one app only.\n  const appData = <PrebootAppData>{ root: appRoot, events: [] };\n  if (prebootData.apps) {\n    prebootData.apps.push(appData);\n  }\n\n  eventSelectors = eventSelectors.map(eventSelector => {\n    if (!eventSelector.hasOwnProperty('replay')) {\n      eventSelector.replay = true;\n    }\n    return eventSelector;\n  });\n\n  // loop through all the eventSelectors and create event handlers\n  eventSelectors.forEach(eventSelector =>\n    handleEvents(_document, prebootData, appData, eventSelector));\n}\n\n/**\n * Create an overlay div and add it to the DOM so it can be used\n * if a freeze event occurs\n *\n * @param _document The global document object (passed in for testing purposes)\n * @returns Element The overlay node is returned\n */\nexport function createOverlay(_document: Document): HTMLElement | undefined {\n  let overlay = _document.createElement('div');\n  overlay.setAttribute('id', 'prebootOverlay');\n  overlay.setAttribute(\n    'style',\n    'display:none;position:absolute;left:0;' +\n    'top:0;width:100%;height:100%;z-index:999999;background:black;opacity:.3'\n  );\n  _document.documentElement.appendChild(overlay);\n\n  return overlay;\n}\n\n/**\n * Get references to the current app root node based on input options. Users can\n * initialize preboot either by specifying appRoot which is just one or more\n * selectors for apps. This section option is useful for people that are doing their own\n * buffering (i.e. they have their own client and server view)\n *\n * @param _document The global document object used to attach the overlay\n * @param opts Options passed in by the user to init()\n * @param serverNode The server node serving as application root\n * @returns ServerClientRoot An array of root info for the current app\n */\nexport function getAppRoot(\n  _document: Document,\n  opts: PrebootOptions,\n  serverNode: HTMLElement\n): ServerClientRoot {\n  const root: ServerClientRoot = {serverNode};\n\n  // if we are doing buffering, we need to create the buffer for the client\n  // else the client root is the same as the server\n  root.clientNode = opts.buffer ? createBuffer(root) : root.serverNode;\n\n  // create an overlay if not disabled ,that can be used later if a freeze event occurs\n  if (!opts.disableOverlay) {\n    root.overlay = createOverlay(_document);\n  }\n\n  return root;\n}\n\n/**\n * Under given server root, for given selector, record events\n *\n * @param _document\n * @param prebootData\n * @param appData\n * @param eventSelector\n */\nexport function handleEvents(_document: Document,\n                             prebootData: PrebootData,\n                             appData: PrebootAppData,\n                             eventSelector: EventSelector) {\n  const serverRoot = appData.root.serverNode;\n\n  // don't do anything if no server root\n  if (!serverRoot) {\n    return;\n  }\n\n  // Attach delegated event listeners for each event selector.\n  // We need to use delegated events as only the top level server node\n  // exists at this point.\n  eventSelector.events.forEach((eventName: string) => {\n    // get the appropriate handler and add it as an event listener\n    const handler = createListenHandler(_document, prebootData, eventSelector, appData);\n    // attach the handler in the capture phase so that it fires even if\n    // one of the handlers below calls stopPropagation()\n    serverRoot.addEventListener(eventName, handler, true);\n\n    // need to keep track of listeners so we can do node.removeEventListener()\n    // when preboot done\n    if (prebootData.listeners) {\n      prebootData.listeners.push({\n        node: serverRoot,\n        eventName,\n        handler\n      });\n    }\n  });\n}\n\n/**\n * Create handler for events that we will record\n */\nexport function createListenHandler(\n  _document: Document,\n  prebootData: PrebootData,\n  eventSelector: EventSelector,\n  appData: PrebootAppData\n): EventListener {\n  const CARET_EVENTS = ['keyup', 'keydown', 'focusin', 'mouseup', 'mousedown'];\n  const CARET_NODES = ['INPUT', 'TEXTAREA'];\n\n  // Support: IE 9-11 only\n  // IE uses a prefixed `matches` version\n  const matches = _document.documentElement.matches ||\n    (_document.documentElement as any).msMatchesSelector;\n  const opts = prebootData.opts;\n\n  return function(event: DomEvent) {\n    const node: Element = event.target;\n\n    // a delegated handlers on document is used so we need to check if\n    // event target matches a desired selector\n    if (!matches.call(node, eventSelector.selector)) {\n      return;\n    }\n\n    const root = appData.root;\n    const eventName = event.type;\n\n    // if no node or no event name, just return\n    if (!node || !eventName) {\n      return;\n    }\n\n    // if key codes set for eventSelector, then don't do anything if event\n    // doesn't include key\n    const keyCodes = eventSelector.keyCodes;\n    if (keyCodes && keyCodes.length) {\n      const matchingKeyCodes = keyCodes.filter(keyCode => event.which === keyCode);\n\n      // if there are not matches (i.e. key entered NOT one of the key codes)\n      // then don't do anything\n      if (!matchingKeyCodes.length) {\n        return;\n      }\n    }\n\n    // if for a given set of events we are preventing default, do that\n    if (eventSelector.preventDefault) {\n      event.preventDefault();\n    }\n\n    // if an action handler passed in, use that\n    if (eventSelector.action) {\n      eventSelector.action(node, event);\n    }\n\n    // get the node key for a given node\n    const nodeKey = getNodeKeyForPreboot({ root: root, node: node });\n\n    // record active node\n    if (CARET_EVENTS.indexOf(eventName) >= 0) {\n      // if it's an caret node, get the selection for the active node\n      const isCaretNode = CARET_NODES.indexOf(node.tagName ? node.tagName : '') >= 0;\n\n      prebootData.activeNode = {\n        root: root,\n        node: node,\n        nodeKey: nodeKey,\n        selection: isCaretNode ? getSelection(node as HTMLInputElement) : undefined\n      };\n    } else if (eventName !== 'change' && eventName !== 'focusout') {\n      prebootData.activeNode = undefined;\n    }\n\n    // if overlay is not disabled and we are freezing the UI\n    if (opts && !opts.disableOverlay && eventSelector.freeze) {\n      const overlay = root.overlay as HTMLElement;\n\n      // show the overlay\n      overlay.style.display = 'block';\n\n      // hide the overlay after 10 seconds just in case preboot.complete() never\n      // called\n      setTimeout(() => {\n        overlay.style.display = 'none';\n      }, 10000);\n    }\n\n    // we will record events for later replay unless explicitly marked as\n    // doNotReplay\n    if (eventSelector.replay) {\n      appData.events.push({\n        node,\n        nodeKey,\n        event,\n        name: eventName\n      });\n    }\n  };\n}\n\n/**\n * Get the selection data that is later used to set the cursor after client view\n * is active\n */\nexport function getSelection(node: HTMLInputElement): PrebootSelection {\n  node = node || {} as HTMLInputElement;\n\n  const nodeValue = node.value || '';\n  const selection: PrebootSelection = {\n    start: nodeValue.length,\n    end: nodeValue.length,\n    direction: 'forward'\n  };\n\n  // if browser support selectionStart on node (Chrome, FireFox, IE9+)\n  try {\n    if (node.selectionStart || node.selectionStart === 0) {\n      selection.start = node.selectionStart;\n      selection.end = node.selectionEnd ? node.selectionEnd : 0;\n      selection.direction = node.selectionDirection ?\n        node.selectionDirection as PrebootSelectionDirection : 'none';\n    }\n  } catch (ex) {}\n\n  return selection;\n}\n\n/**\n * Create buffer for a given node\n *\n * @param root All the data related to a particular app\n * @returns Returns the root client node.\n */\nexport function createBuffer(root: ServerClientRoot): HTMLElement {\n  const serverNode = root.serverNode;\n\n  // if no rootServerNode OR the selector is on the entire html doc or the body\n  // OR no parentNode, don't buffer\n  if (!serverNode || !serverNode.parentNode ||\n    serverNode === document.documentElement || serverNode === document.body) {\n    return serverNode as HTMLElement;\n  }\n\n  // create shallow clone of server root\n  const rootClientNode = serverNode.cloneNode(false) as HTMLElement;\n  // we want the client to write to a hidden div until the time for switching\n  // the buffers\n  rootClientNode.style.display = 'none';\n\n  // insert the client node before the server and return it\n  serverNode.parentNode.insertBefore(rootClientNode, serverNode);\n\n  // mark server node as not to be touched by AngularJS - needed for ngUpgrade\n  serverNode.setAttribute('ng-non-bindable', '');\n\n  // return the rootClientNode\n  return rootClientNode;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {PrebootOptions} from '../common/preboot.interfaces';\nimport {getNodeKeyForPreboot} from '../common/get-node-key';\n\nimport {\n  initAll,\n  start,\n  createOverlay,\n  getAppRoot,\n  handleEvents,\n  createListenHandler,\n  getSelection,\n  createBuffer\n} from './event.recorder';\n\nconst eventRecorder = {\n  start,\n  createOverlay,\n  getAppRoot,\n  handleEvents,\n  createListenHandler,\n  getSelection,\n  createBuffer\n};\n\nexport const initFunctionName = 'prebootInitFn';\n\n// exporting default options in case developer wants to use these + custom on\n// top\nexport const defaultOptions = <PrebootOptions>{\n  buffer: true,\n  replay: true,\n  disableOverlay: false,\n\n  // these are the default events are are listening for an transferring from\n  // server view to client view\n  eventSelectors: [\n    // for recording changes in form elements\n    {\n      selector: 'input,textarea',\n      events: ['keypress', 'keyup', 'keydown', 'input', 'change']\n    },\n    { selector: 'select,option', events: ['change'] },\n\n    // when user hits return button in an input box\n    {\n      selector: 'input',\n      events: ['keyup'],\n      preventDefault: true,\n      keyCodes: [13],\n      freeze: true\n    },\n\n    // when user submit form (press enter, click on button/input[type=\"submit\"])\n    {\n      selector: 'form',\n      events: ['submit'],\n      preventDefault: true,\n      freeze: true\n    },\n\n    // for tracking focus (no need to replay)\n    {\n      selector: 'input,textarea',\n      events: ['focusin', 'focusout', 'mousedown', 'mouseup'],\n      replay: false\n    },\n\n    // user clicks on a button\n    {\n      selector: 'button',\n      events: ['click'],\n      preventDefault: true,\n      freeze: true\n    }\n  ]\n};\n\n/**\n * Get the event recorder code based on all functions in event.recorder.ts\n * and the getNodeKeyForPreboot function.\n */\nexport function getEventRecorderCode(): string {\n  const eventRecorderFunctions: string[] = [];\n\n  for (const funcName in eventRecorder) {\n    if (eventRecorder.hasOwnProperty(funcName)) {\n      const fn = (<any>eventRecorder)[funcName].toString();\n      const fnCleaned = fn.replace('common_1.', '');\n      eventRecorderFunctions.push(fnCleaned);\n    }\n  }\n\n  // this is common function used to get the node key\n  eventRecorderFunctions.push(getNodeKeyForPreboot.toString());\n\n  // add new line characters for readability\n  return '\\n\\n' + eventRecorderFunctions.join('\\n\\n') + '\\n\\n';\n}\n\n/**\n * Used by the server side version of preboot. The main purpose is to get the\n * inline code that can be inserted into the server view.\n * Returns the definitions of the prebootInit function called in code returned by\n * getInlineInvocation for each server node separately.\n *\n * @param customOptions PrebootRecordOptions that override the defaults\n * @returns Generated inline preboot code with just functions definitions\n * to be used separately\n */\nexport function getInlineDefinition(customOptions?: PrebootOptions): string {\n  const opts = <PrebootOptions>assign({}, defaultOptions, customOptions);\n\n  // safety check to make sure options passed in are valid\n  validateOptions(opts);\n\n  const scriptCode = getEventRecorderCode();\n  const optsStr = stringifyWithFunctions(opts);\n\n  // wrap inline preboot code with a self executing function in order to create scope\n  const initAllStr = initAll.toString();\n  return `var ${initFunctionName} = (function() {\n      ${scriptCode}\n      return (${initAllStr.replace('common_1.', '')})(${optsStr});\n    })();`;\n}\n\n\n/**\n * Used by the server side version of preboot. The main purpose is to get the\n * inline code that can be inserted into the server view.\n * Invokes the prebootInit function defined in getInlineDefinition with proper\n * parameters. Each appRoot should get a separate inlined code from a separate\n * call to getInlineInvocation but only one inlined code from getInlineDefinition.\n *\n * @returns Generated inline preboot code with just invocations of functions from\n * getInlineDefinition\n */\nexport function getInlineInvocation(): string {\n  return `${initFunctionName}();`;\n}\n\n/**\n * Throw an error if issues with any options\n * @param opts\n */\nexport function validateOptions(opts: PrebootOptions) {\n  if (!opts.appRoot || !opts.appRoot.length) {\n    throw new Error(\n      'The appRoot is missing from preboot options. ' +\n        'This is needed to find the root of your application. ' +\n        'Set this value in the preboot options to be a selector for the root element of your app.'\n    );\n  }\n}\n\n/**\n * Object.assign() is not fully supporting in TypeScript, so\n * this is just a simple implementation of it\n *\n * @param target The target object\n * @param optionSets Any number of addition objects that are added on top of the\n * target\n * @returns A new object that contains all the merged values\n */\nexport function assign(target: Object, ...optionSets: any[]): Object {\n  if (target === undefined || target === null) {\n    throw new TypeError('Cannot convert undefined or null to object');\n  }\n\n  const output = Object(target);\n  for (let index = 0; index < optionSets.length; index++) {\n    const source = optionSets[index];\n    if (source !== undefined && source !== null) {\n      for (const nextKey in source) {\n        if (source.hasOwnProperty && source.hasOwnProperty(nextKey)) {\n          output[nextKey] = source[nextKey];\n        }\n      }\n    }\n  }\n\n  return output;\n}\n\n/**\n * Stringify an object and include functions. This is needed since we are\n * letting users pass in options that include custom functions for things like\n * the freeze handler or action when an event occurs\n *\n * @param obj This is the object you want to stringify that includes some\n * functions\n * @returns The stringified version of an object\n */\nexport function stringifyWithFunctions(obj: Object): string {\n  const FUNC_START = 'START_FUNCTION_HERE';\n  const FUNC_STOP = 'STOP_FUNCTION_HERE';\n\n  // first stringify except mark off functions with markers\n  let str = JSON.stringify(obj, function(_key, value) {\n    // if the value is a function, we want to wrap it with markers\n    if (!!(value && value.constructor && value.call && value.apply)) {\n      return FUNC_START + value.toString() + FUNC_STOP;\n    } else {\n      return value;\n    }\n  });\n\n  // now we use the markers to replace function strings with actual functions\n  let startFuncIdx = str.indexOf(FUNC_START);\n  let stopFuncIdx: number;\n  let fn: string;\n  while (startFuncIdx >= 0) {\n    stopFuncIdx = str.indexOf(FUNC_STOP);\n\n    // pull string out\n    fn = str.substring(startFuncIdx + FUNC_START.length, stopFuncIdx);\n    fn = fn.replace(/\\\\n/g, '\\n');\n\n    str = str.substring(0, startFuncIdx - 1) + fn +\n      str.substring(stopFuncIdx + FUNC_STOP.length + 1);\n    startFuncIdx = str.indexOf(FUNC_START);\n  }\n\n  return str;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  APP_BOOTSTRAP_LISTENER,\n  ApplicationRef,\n  Inject,\n  InjectionToken,\n  Optional,\n  PLATFORM_ID\n} from '@angular/core';\nimport {DOCUMENT, isPlatformBrowser, isPlatformServer} from '@angular/common';\nimport {filter, take} from 'rxjs/operators';\n\nimport {EventReplayer} from './api/event.replayer';\nimport {PREBOOT_NONCE} from './common/tokens';\nimport {getInlineDefinition, getInlineInvocation} from './api/inline.preboot.code';\nimport {PrebootOptions} from './common/preboot.interfaces';\nimport {validateOptions} from './api';\n\nconst PREBOOT_SCRIPT_CLASS = 'preboot-inline-script';\nexport const PREBOOT_OPTIONS = new InjectionToken<PrebootOptions>('PrebootOptions');\n\nfunction createScriptFromCode(doc: Document, nonce: string|null, inlineCode: string) {\n  const script = doc.createElement('script');\n  if (nonce) {\n    (script as any).nonce = nonce;\n  }\n  script.className = PREBOOT_SCRIPT_CLASS;\n  script.textContent = inlineCode;\n\n  return script;\n}\n\nexport function PREBOOT_FACTORY(doc: Document,\n                                prebootOpts: PrebootOptions,\n                                nonce: string|null,\n                                platformId: Object,\n                                appRef: ApplicationRef,\n                                eventReplayer: EventReplayer) {\n  return () => {\n    validateOptions(prebootOpts);\n\n    if (isPlatformServer(platformId)) {\n      const inlineCodeDefinition = getInlineDefinition(prebootOpts);\n      const scriptWithDefinition = createScriptFromCode(doc, nonce, inlineCodeDefinition);\n      const inlineCodeInvocation = getInlineInvocation();\n\n      const existingScripts = doc.getElementsByClassName(PREBOOT_SCRIPT_CLASS);\n\n      // Check to see if preboot scripts are already inlined before adding them\n      // to the DOM. If they are, update the nonce to be current.\n      if (existingScripts.length === 0) {\n        const baseList: string[] = [];\n        const appRootSelectors = baseList.concat(prebootOpts.appRoot);\n        doc.head.appendChild(scriptWithDefinition);\n        appRootSelectors\n          .map(selector => ({\n            selector,\n            appRootElem: doc.querySelector(selector)\n          }))\n          .forEach(({selector, appRootElem}) => {\n            if (!appRootElem) {\n              console.log(`No server node found for selector: ${selector}`);\n              return;\n            }\n            const scriptWithInvocation = createScriptFromCode(doc, nonce, inlineCodeInvocation);\n            appRootElem.insertBefore(scriptWithInvocation, appRootElem.firstChild);\n          });\n      } else if (existingScripts.length > 0 && nonce) {\n        (existingScripts[0] as any).nonce = nonce;\n      }\n    }\n    if (isPlatformBrowser(platformId)) {\n      const replay = prebootOpts.replay != null ? prebootOpts.replay : true;\n      if (replay) {\n        appRef.isStable\n          .pipe(\n            filter(stable => stable),\n            take(1)\n          ).subscribe(() => {\n          eventReplayer.replayAll();\n        });\n      }\n    }\n  };\n}\n\nexport const PREBOOT_PROVIDER = {\n  provide: <InjectionToken<() => void>>APP_BOOTSTRAP_LISTENER,\n  useFactory: PREBOOT_FACTORY,\n  deps: [\n    DOCUMENT,\n    PREBOOT_OPTIONS,\n    [new Optional(), new Inject(PREBOOT_NONCE)],\n    PLATFORM_ID,\n    ApplicationRef,\n    EventReplayer,\n  ],\n  multi: true\n};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {ModuleWithProviders, NgModule} from '@angular/core';\n\nimport {EventReplayer} from './api/event.replayer';\nimport {PrebootOptions} from './common/preboot.interfaces';\nimport {PREBOOT_OPTIONS, PREBOOT_PROVIDER} from './provider';\n\n@NgModule({\n  providers: [EventReplayer, PREBOOT_PROVIDER]\n})\nexport class PrebootModule {\n  static withConfig(opts: PrebootOptions): ModuleWithProviders<PrebootModule> {\n    return {\n      ngModule: PrebootModule,\n      providers: [{provide: PREBOOT_OPTIONS, useValue: opts}]\n    };\n  }\n}\n"]}